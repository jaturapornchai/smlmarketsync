package config

import (
	"fmt"
	"strings"
	"time"
)

// CreatePriceTable ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á ic_inventory_price
func (api *APIClient) CreatePriceTable() error {
	query := `
		CREATE TABLE IF NOT EXISTS ic_inventory_price (
			id SERIAL PRIMARY KEY,
			row_order_ref INT DEFAULT 0,
			ic_code VARCHAR(50) NOT NULL,
			unit_code VARCHAR(20),
			from_qty DECIMAL(15,6) DEFAULT 0,
			to_qty DECIMAL(15,6) DEFAULT 0,
			from_date DATE,
			to_date DATE,
			sale_type VARCHAR(20),
			sale_price1 DECIMAL(15,6) DEFAULT 0,
			status VARCHAR(20) DEFAULT 'active',
			price_type VARCHAR(20),			
			cust_code VARCHAR(50),
			sale_price2 DECIMAL(15,6) DEFAULT 0,
			cust_group_1 VARCHAR(50),
			price_mode VARCHAR(20)
		)
	`

	resp, err := api.ExecuteCommand(query)
	if err != nil {
		// Try to continue even if there's an error, the table might already exist
		fmt.Printf("‚ö†Ô∏è Warning: Error creating price table, continuing anyway: %v\n", err)
		return nil
	}

	if !resp.Success {
		// Try to continue even if there's an error, the table might already exist
		fmt.Printf("‚ö†Ô∏è Warning: Failed to create price table, continuing anyway: %s\n", resp.Message)
		return nil
	}

	return nil
}

// SyncPriceData ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÅ‡∏ö‡∏ö batch (‡πÅ‡∏¢‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï)
func (api *APIClient) SyncPriceData(syncIds []int, inserts []interface{}, updates []interface{}, deletes []interface{}) {
	if len(inserts) == 0 && len(updates) == 0 && len(deletes) == 0 && len(syncIds) == 0 {
		fmt.Println("‚ÑπÔ∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£")
		return
	}

	// 1. ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å sml_market_sync ‡∏î‡πâ‡∏ß‡∏¢ syncIds
	if len(syncIds) > 0 {
		_, err := api.deleteFromTable("sml_market_sync", "id", toInterfaceSlice(syncIds), false)
		if err != nil {
			fmt.Printf("‚ö†Ô∏è Warning: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å sml_market_sync ‡πÑ‡∏î‡πâ: %v\n", err)
			// Continue anyway
		} else {
			fmt.Println("‚úÖ ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å sml_market_sync ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß")
		}
	} else {
		fmt.Println("‚úÖ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏•‡∏ö‡∏à‡∏≤‡∏Å sml_market_sync")
	}
	// 2. ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å ic_inventory_price ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
	if len(deletes) > 0 {
		fmt.Println("üóëÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏≤‡∏Å ic_inventory_price")

		// ‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏° row_order_ref ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡∏ö
		var rowOrderRefs []interface{}
		for _, item := range deletes {
			if itemMap, ok := item.(map[string]interface{}); ok {
				if rowOrderRef, exists := itemMap["row_order_ref"]; exists && rowOrderRef != nil {
					rowOrderRefs = append(rowOrderRefs, fmt.Sprintf("%v", rowOrderRef))
				}
			}
		}

		if len(rowOrderRefs) > 0 {
			_, err := api.deleteFromTable("ic_inventory_price", "row_order_ref", rowOrderRefs, true)
			if err != nil {
				fmt.Printf("‚ö†Ô∏è Warning: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å ic_inventory_price ‡πÑ‡∏î‡πâ: %v\n", err)
				// Continue anyway
			} else {
				fmt.Println("‚úÖ ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å ic_inventory_price ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß")
			}
		} else {
			fmt.Println("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö row_order_ref ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö")
		}
	} else {
		fmt.Println("‚úÖ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏•‡∏ö‡∏à‡∏≤‡∏Å ic_inventory_price")
	}
	// 3. ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• inserts ‡πÅ‡∏ö‡∏ö batch (‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏•‡∏∞ 100 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)
	insertCount := 0
	if len(inserts) > 0 {
		count, err := api.processPriceBatch(inserts, 100, false)
		if err != nil {
			fmt.Printf("‚ö†Ô∏è Warning: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ: %v\n", err)
			// Continue anyway
		} else {
			insertCount = count
		}
	} else {
		fmt.Println("‚úÖ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°")
	} // 4. ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• updates ‡πÅ‡∏ö‡∏ö batch (‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏•‡∏∞ 100 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)
	updateCount := 0
	if len(updates) > 0 {
		count, err := api.processPriceBatch(updates, 100, true)
		if err != nil {
			fmt.Printf("‚ö†Ô∏è Warning: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: %v\n", err)
			// Continue anyway
		} else {
			updateCount = count
		}
	} else {
		fmt.Println("‚úÖ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï")
	}
	// ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£
	fmt.Printf("\nüìä ‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤:\n")
	fmt.Printf("   - ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å sml_market_sync: %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n", len(syncIds))
	fmt.Printf("   - ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å ic_inventory_price: %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n", len(deletes))
	fmt.Printf("   - ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà: %d/%d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n", insertCount, len(inserts))
	fmt.Printf("   - ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: %d/%d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n", updateCount, len(updates))
}

// executeBatchInsertPrice ‡∏ó‡∏≥ batch INSERT ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ (‡πÑ‡∏°‡πà‡∏°‡∏µ retry, ‡∏ñ‡πâ‡∏≤‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏à‡∏∞‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ)
func (api *APIClient) executeBatchInsertPrice(values []string) error {
	if len(values) == 0 {
		return nil
	}
	query := fmt.Sprintf(`
		INSERT INTO ic_inventory_price (ic_code, unit_code, from_qty, to_qty, from_date, to_date, 
										sale_type, sale_price1, status, price_type, cust_code, 
										sale_price2, cust_group_1, price_mode)
		VALUES %s;`,
		strings.Join(values, ",")) // ‡∏ó‡∏≥‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÑ‡∏°‡πà‡∏°‡∏µ retry
	var lastErr error

	resp, err := api.ExecuteCommand(query)
	if err != nil {
		lastErr = fmt.Errorf("error executing batch insert price: %v", err)
		fmt.Printf("‚ùå ERROR: %v\n", lastErr)
		return lastErr
	}

	if !resp.Success {
		lastErr = fmt.Errorf("batch insert price failed: %s", resp.Message)
		fmt.Printf("‚ùå ERROR: %v\n", lastErr)
		return lastErr
	}

	return nil
}

// Helper functions ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö price sync
func parseFloatValue(value interface{}) string {
	if value == nil {
		return "0"
	}

	switch v := value.(type) {
	case float64:
		return fmt.Sprintf("%.6f", v)
	case string:
		if v == "" || v == "<nil>" {
			return "0"
		}
		return v
	default:
		return fmt.Sprintf("%v", v)
	}
}

func parseStringValue(value interface{}) string {
	if value == nil {
		return ""
	}
	return fmt.Sprintf("%v", value)
}

func nullableDate(dateStr string) string {
	if dateStr == "" || dateStr == "<nil>" {
		return "NULL"
	}
	return fmt.Sprintf("'%s'", dateStr)
}

// prepPriceDataValues ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á SQL
func prepPriceDataValues(item map[string]interface{}) (string, error) {
	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏£‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	if item["ic_code"] == nil || item["unit_code"] == nil {
		return "", fmt.Errorf("‡πÑ‡∏°‡πà‡∏°‡∏µ ic_code ‡∏´‡∏£‡∏∑‡∏≠ unit_code")
	}

	// ‡∏î‡∏∂‡∏á row_order_ref ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á
	rowOrderRef := ""
	if item["row_order_ref"] != nil {
		rowOrderRef = fmt.Sprintf("%v", item["row_order_ref"])
	} else {
		return "", fmt.Errorf("‡πÑ‡∏°‡πà‡∏°‡∏µ row_order_ref")
	}

	// ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö SQL
	icCode := fmt.Sprintf("%v", item["ic_code"])
	unitCode := fmt.Sprintf("%v", item["unit_code"])
	fromQty := parseFloatValue(item["from_qty"])
	toQty := parseFloatValue(item["to_qty"])
	fromDate := parseStringValue(item["from_date"])
	toDate := parseStringValue(item["to_date"])
	saleType := parseStringValue(item["sale_type"])
	salePrice1 := parseFloatValue(item["sale_price1"])
	status := parseStringValue(item["status"])
	priceType := parseStringValue(item["price_type"])
	custCode := parseStringValue(item["cust_code"])
	salePrice2 := parseFloatValue(item["sale_price2"])
	custGroup1 := parseStringValue(item["cust_group_1"])
	priceMode := parseStringValue(item["price_mode"])

	// Escape single quotes
	icCode = strings.ReplaceAll(icCode, "'", "''")
	unitCode = strings.ReplaceAll(unitCode, "'", "''")
	saleType = strings.ReplaceAll(saleType, "'", "''")
	status = strings.ReplaceAll(status, "'", "''")
	priceType = strings.ReplaceAll(priceType, "'", "''")
	custCode = strings.ReplaceAll(custCode, "'", "''")
	custGroup1 = strings.ReplaceAll(custGroup1, "'", "''")
	priceMode = strings.ReplaceAll(priceMode, "'", "''")

	// Format the values for SQL
	fromDateStr := nullableDate(fromDate)
	toDateStr := nullableDate(toDate)

	value := fmt.Sprintf("(%s, '%s', '%s', %s, %s, %s, %s, '%s', %s, '%s', '%s', '%s', %s, '%s', '%s')",
		rowOrderRef, 
		icCode, 
		unitCode, 
		fromQty, 
		toQty,
		fromDateStr, 
		toDateStr,
		saleType, 
		salePrice1, 
		status, 
		priceType, 
		custCode,
		salePrice2, 
		custGroup1, 
		priceMode)

	return value, nil
}

// deleteFromTable ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
func (api *APIClient) deleteFromTable(tableName string, idColumn string, ids []interface{}, idIsString bool) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}

	fmt.Printf("üóëÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á %s: %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n", tableName, len(ids))

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á DELETE
	deleteQuery := fmt.Sprintf("DELETE FROM %s WHERE %s IN (", tableName, idColumn)

	for i, id := range ids {
		if idIsString {
			// ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô string ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ quotes
			deleteQuery += fmt.Sprintf("'%v'", id)
		} else {
			// ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ quotes
			deleteQuery += fmt.Sprintf("%v", id)
		}

		if i < len(ids)-1 {
			deleteQuery += ","
		}
	}
	deleteQuery += ")"

	// ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	resp, err := api.ExecuteCommand(deleteQuery)
	if err != nil {
		fmt.Printf("‚ùå ERROR: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å %s ‡πÑ‡∏î‡πâ: %v\n", tableName, err)
		return 0, err
	}

	if !resp.Success {
		fmt.Printf("‚ùå ERROR: ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å %s ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: %s\n", tableName, resp.Message)
		return 0, fmt.Errorf("‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: %s", resp.Message)
	}

	fmt.Printf("‚úÖ ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å %s ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß: %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n", tableName, len(ids))
	return len(ids), nil
}

// deleteFromTableInBatches ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡πÅ‡∏ö‡∏ö‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô batch
func (api *APIClient) deleteFromTableInBatches(tableName string, idColumn string, ids []interface{}, idIsString bool, batchSize int) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}

	totalItems := len(ids)
	fmt.Printf("üóëÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á %s: %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ (‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô batch ‡∏•‡∏∞ %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)\n",
		tableName, totalItems, batchSize)

	// ‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô batch
	batchCount := (totalItems + batchSize - 1) / batchSize
	totalDeleted := 0
	successBatches := 0
	failedBatches := 0

	for b := 0; b < batchCount; b++ {
		start := b * batchSize
		end := start + batchSize
		if end > totalItems {
			end = totalItems
		}

		batchIds := ids[start:end]
		currentBatchSize := len(batchIds)

		fmt.Printf("   üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏ö batch ‡∏ó‡∏µ‡πà %d/%d (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ %d-%d) ‡∏à‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n",
			b+1, batchCount, start+1, end, totalItems)

		// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á DELETE ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö batch ‡∏ô‡∏µ‡πâ
		deleteQuery := fmt.Sprintf("DELETE FROM %s WHERE %s IN (", tableName, idColumn)

		for i, id := range batchIds {
			if idIsString {
				// ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô string ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ quotes
				deleteQuery += fmt.Sprintf("'%v'", id)
			} else {
				// ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ quotes
				deleteQuery += fmt.Sprintf("%v", id)
			}

			if i < len(batchIds)-1 {
				deleteQuery += ","
			}
		}
		deleteQuery += ")"

		// ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
		resp, err := api.ExecuteCommand(deleteQuery)
		if err != nil {
			fmt.Printf("   ‚ùå ERROR: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• batch ‡∏ó‡∏µ‡πà %d ‡∏à‡∏≤‡∏Å %s ‡πÑ‡∏î‡πâ: %v\n",
				b+1, tableName, err)
			failedBatches++
			// ‡∏ó‡∏≥ batch ‡∏ï‡πà‡∏≠‡πÑ‡∏õ
			continue
		}

		if !resp.Success {
			fmt.Printf("   ‚ùå ERROR: ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• batch ‡∏ó‡∏µ‡πà %d ‡∏à‡∏≤‡∏Å %s ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: %s\n",
				b+1, tableName, resp.Message)
			failedBatches++
			// ‡∏ó‡∏≥ batch ‡∏ï‡πà‡∏≠‡πÑ‡∏õ
			continue
		}

		totalDeleted += currentBatchSize
		successBatches++
		fmt.Printf("   ‚úÖ ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• batch ‡∏ó‡∏µ‡πà %d ‡∏à‡∏≤‡∏Å %s ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n",
			b+1, tableName, currentBatchSize)

		// ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á batch ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏†‡∏≤‡∏£‡∏∞‡∏Ç‡∏≠‡∏á server
		if b < batchCount-1 {
			time.Sleep(100 * time.Millisecond)
		}
	}

	// ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£
	if failedBatches > 0 {
		fmt.Printf("‚ö†Ô∏è ‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å %s: ‡∏•‡∏ö‡πÑ‡∏î‡πâ %d/%d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ (%d/%d batches ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à)\n",
			tableName, totalDeleted, totalItems, successBatches, batchCount)
		return totalDeleted, fmt.Errorf("‡∏°‡∏µ‡∏ö‡∏≤‡∏á batch ‡∏ó‡∏µ‡πà‡∏•‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (%d/%d batches ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)",
			failedBatches, batchCount)
	}

	fmt.Printf("‚úÖ ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å %s ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß: %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ (%d batches)\n",
		tableName, totalDeleted, batchCount)
	return totalDeleted, nil
}

// processPriceBatch ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô batch
func (api *APIClient) processPriceBatch(data []interface{}, batchSize int, isUpdate bool) (int, error) {
	if len(data) == 0 {
		return 0, nil
	}

	operationType := "‡πÄ‡∏û‡∏¥‡πà‡∏°"
	if isUpdate {
		operationType = "‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï"
	}

	fmt.Printf("üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á%s‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ (batch ‡∏•‡∏∞ %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)\n", operationType, len(data), batchSize)

	// ‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô batch
	batchCount := (len(data) + batchSize - 1) / batchSize
	totalProcessed := 0

	for b := 0; b < batchCount; b++ {
		start := b * batchSize
		end := start + batchSize
		if end > len(data) {
			end = len(data)
		}

		currentBatch := data[start:end]
		fmt.Printf("   üì¶ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• batch ‡∏ó‡∏µ‡πà %d/%d (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ %d-%d) ‡∏à‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n",
			b+1, batchCount, start+1, end, len(data))

		// ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö batch
		var batchValues []string

		for _, item := range currentBatch {
			if itemMap, ok := item.(map[string]interface{}); ok {
				value, err := prepPriceDataValues(itemMap)
				if err != nil {
					fmt.Printf("‚ö†Ô∏è ‡∏Ç‡πâ‡∏≤‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£: %v - %v\n", err, itemMap)
					continue
				}
				batchValues = append(batchValues, value)
			} else {
				fmt.Printf("‚ö†Ô∏è ‡∏Ç‡πâ‡∏≤‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà map: %v\n", item)
			}
		}
		// ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô batch
		if len(batchValues) > 0 {
			var query string
			
			if isUpdate {
				// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö UPDATE ‡πÉ‡∏ä‡πâ UPSERT (INSERT ... ON CONFLICT DO UPDATE)
				query = fmt.Sprintf(`
					INSERT INTO ic_inventory_price (
						row_order_ref, ic_code, unit_code, from_qty, to_qty, from_date, to_date, 
						sale_type, sale_price1, status, price_type, cust_code, 
						sale_price2, cust_group_1, price_mode
					)
					VALUES %s
					ON CONFLICT (row_order_ref) DO UPDATE SET
						ic_code = EXCLUDED.ic_code,
						unit_code = EXCLUDED.unit_code,
						from_qty = EXCLUDED.from_qty,
						to_qty = EXCLUDED.to_qty,
						from_date = EXCLUDED.from_date,
						to_date = EXCLUDED.to_date,
						sale_type = EXCLUDED.sale_type,
						sale_price1 = EXCLUDED.sale_price1,
						status = EXCLUDED.status,
						price_type = EXCLUDED.price_type,
						cust_code = EXCLUDED.cust_code,
						sale_price2 = EXCLUDED.sale_price2,
						cust_group_1 = EXCLUDED.cust_group_1,
						price_mode = EXCLUDED.price_mode;`,
					strings.Join(batchValues, ","))
			} else {
				// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö INSERT ‡∏õ‡∏Å‡∏ï‡∏¥
				query = fmt.Sprintf(`
					INSERT INTO ic_inventory_price (
						row_order_ref, ic_code, unit_code, from_qty, to_qty, from_date, to_date, 
						sale_type, sale_price1, status, price_type, cust_code, 
						sale_price2, cust_group_1, price_mode
					)
					VALUES %s;`,
					strings.Join(batchValues, ","))
			}

			resp, err := api.ExecuteCommand(query)
			if err != nil {
				fmt.Printf("‚ùå ERROR: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ%s‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (batch %d) ‡πÑ‡∏î‡πâ: %v\n", operationType, b+1, err)
				continue
			}

			if !resp.Success {
				fmt.Printf("‚ùå ERROR: %s‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (batch %d) ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: %s\n", operationType, b+1, resp.Message)
				continue
			}

			totalProcessed += len(batchValues)
			fmt.Printf("   ‚úÖ %s‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• batch %d ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n", operationType, b+1, len(batchValues))
		}

		// ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á batch
		if b < batchCount-1 {
			time.Sleep(100 * time.Millisecond)
		}
	}

	fmt.Printf("‚úÖ %s‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß: %d ‡∏à‡∏≤‡∏Å %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n", operationType, totalProcessed, len(data))
	return totalProcessed, nil
}

// toInterfaceSlice ‡πÅ‡∏õ‡∏•‡∏á slice ‡∏Ç‡∏≠‡∏á int ‡πÄ‡∏õ‡πá‡∏ô slice ‡∏Ç‡∏≠‡∏á interface{}
func toInterfaceSlice(ints []int) []interface{} {
	result := make([]interface{}, len(ints))
	for i, v := range ints {
		result[i] = v
	}
	return result
}
